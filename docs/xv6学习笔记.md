## 1.虚拟内存（page table）

​	绝大多数的操作系统的内存页是4k这是由硬件决定的。TLB（Translation Lookaside Buffer）是硬件的设计实现（硬件）的但是操作系统知道TLB的存在。且在切换页表的时候会告诉硬件(CUP?)清空TLB。

> 注意区别TLB缓存和数据页缓存这两个是不同的东西。
>
> MMU（member managmet unit）也是硬件的一部分。

虚拟内存的翻译流程图:

![image-20250529102216913](D:\lya\xv6-riscv\docs\image\image-20250529102216913.png)

### ✅ 一句话总结：

> **页表（Page Table）是操作系统创建并维护的数据结构，但由硬件中的内存管理单元（MMU）读取和使用进行地址转换。**

------

### 🔧 一、页表是由操作系统创建和维护的

- 当一个进程被创建时，操作系统（如 Linux）会为它分配虚拟地址空间，并分配对应的页表。
- 页表会记录每个虚拟页映射到哪个物理页（或者未映射、在磁盘上等状态）。
- 页表的结构（多级页表、一维页表等）是由 **CPU 架构定义**，比如 x86 使用多级页表，ARM 也支持类似设计，但**填充内容、分配页表项是 OS 来做的**。
- 操作系统负责：
  - 分配页表物理页
  - 设置页表项（PTE）中的 flag：有效位、读写权限、用户态/内核态、是否在 swap 中等
  - 响应 page fault 中断（当页表缺项或无权限时）

------

### ⚙️ 二、地址翻译是由硬件（MMU）完成的

- 每次 CPU 访问内存时，如果启用了虚拟内存机制，**都会先通过 MMU 查找页表，将虚拟地址转换成物理地址**。
- MMU 根据当前运行进程的页目录基地址（通常保存在寄存器 CR3）开始，从页表中查找对应的映射。
- 为了加速这个过程，MMU 会使用 **TLB（Translation Lookaside Buffer）** 缓存最近的页表项，减少实际访问页表的次数。

------

### 🔍 三、操作系统和硬件的协作流程图

```
markdown复制编辑用户进程访问虚拟地址 VA
        ↓
CPU 交给 MMU
        ↓
TLB 命中？ ──▶ 是 → 得到物理地址 → 访问内存
        ↓ 否
MMU 遍历页表（需要访问内存）
        ↓
是否页表项有效？
    ↓          ↓
 是 → 得到物理地址     否 → 触发 page fault → 操作系统介入
```

------

### 📌 举例说明（x86_64 多级页表）

在 x86-64 架构下，一个虚拟地址会通过 4 级页表转换：

- CR3 → PML4 → PDPT → PD → PT → page
- 每级页表由 OS 分配并维护
- 每次进程切换，OS 会更新 CR3 指向该进程的页表根

------

### ✅ 总结

| 组件                 | 角色   | 说明                                    |
| -------------------- | ------ | --------------------------------------- |
| 操作系统             | 管理者 | 负责创建、维护页表结构，处理 page fault |
| MMU（硬件）          | 使用者 | 读取页表完成虚拟地址到物理地址的转换    |
| CPU 寄存器（如 CR3） | 配置点 | 指向当前页表的根地址（通常是页目录表）  |



------

如你对具体页表结构、页表项格式、如何响应 page fault 或 Linux 中如何管理页表感兴趣，我可以进一步为你展开。